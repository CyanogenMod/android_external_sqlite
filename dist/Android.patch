diff -r -u -d orig/shell.c ./shell.c
--- orig/shell.c	2014-09-09 10:51:34.413220429 +0900
+++ ./shell.c	2014-09-09 10:51:34.436220428 +0900
@@ -35,6 +35,11 @@
 #include "sqlite3.h"
 #include <ctype.h>
 #include <stdarg.h>
+// Begin Android Add
+#ifndef NO_ANDROID_FUNCS
+#include <sqlite3_android.h>
+#endif
+// End Android Add
 
 #if !defined(_WIN32) && !defined(WIN32)
 # include <signal.h>
@@ -1126,6 +1131,20 @@
     sqlite3_status(SQLITE_STATUS_PARSER_STACK, &iCur, &iHiwtr, bReset);
     fprintf(pArg->out, "Deepest Parser Stack:                %d (max %d)\n", iCur, iHiwtr);
 #endif
+    // Begin Android Add
+    #ifndef NO_ANDROID_FUNCS
+        int err = register_localized_collators(db, "en_US", 0);
+        if (err != SQLITE_OK) {
+          fprintf(stderr, "register_localized_collators() failed\n");
+          exit(1);
+        }
+        err = register_android_functions(db, 0);
+        if (err != SQLITE_OK) {
+          fprintf(stderr, "register_android_functions() failed\n");
+          exit(1);
+        }
+    #endif
+    // End Android Add
   }
 
   if( pArg && pArg->out && db ){
diff -r -u -d orig/sqlite3.c ./sqlite3.c
--- orig/sqlite3.c	2014-09-09 10:51:34.434220428 +0900
+++ ./sqlite3.c	2014-09-09 10:51:34.456220427 +0900
@@ -25,6 +25,13 @@
 #ifndef SQLITE_API
 # define SQLITE_API
 #endif
+#ifdef QC_PERF
+extern void sqlite3_androidopt_init(void*, const char*) __attribute__((weak));
+extern void sqlite3_androidopt_open(void*, const char*, unsigned, int*) __attribute__((weak));
+extern void sqlite3_androidopt_close(void*) __attribute__((weak));
+extern int  sqlite3_androidopt_handle_pragma(void*, char*, char*) __attribute__((weak));
+#endif
+
 /************** Begin file sqliteInt.h ***************************************/
 /*
 ** 2001 September 15
@@ -10539,6 +10546,7 @@
   void (*xUnlockNotify)(void **, int);  /* Unlock notify callback */
   sqlite3 *pNextBlocked;        /* Next in list of all blocked connections */
 #endif
+  u8 isSettingOverride;         /* True if db settings have been overridden */
 };
 
 /*
@@ -24109,6 +24117,13 @@
 */
 #if SQLITE_OS_UNIX              /* This file is used on unix only */
 
+/* Use posix_fallocate() if it is available
+*/
+#if !defined(HAVE_POSIX_FALLOCATE) && !defined(__ANDROID__) \
+      && (_XOPEN_SOURCE >= 600 || _POSIX_C_SOURCE >= 200112L)
+# define HAVE_POSIX_FALLOCATE 1
+#endif
+
 /*
 ** There are various methods for file locking used for concurrency
 ** control:
@@ -24660,7 +24675,12 @@
 #else
   { "pread64",      (sqlite3_syscall_ptr)0,          0  },
 #endif
+#ifdef ANDROID
+// Bionic defines pread64 using off64_t rather than off_t.
+#define osPread64   ((ssize_t(*)(int,void*,size_t,off64_t))aSyscall[10].pCurrent)
+#else
 #define osPread64   ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[10].pCurrent)
+#endif
 
   { "write",        (sqlite3_syscall_ptr)write,      0  },
 #define osWrite     ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)
@@ -24678,8 +24698,14 @@
 #else
   { "pwrite64",     (sqlite3_syscall_ptr)0,          0  },
 #endif
+#ifdef ANDROID
+// Bionic defines pwrite64 using off64_t rather than off_t.
+#define osPwrite64  ((ssize_t(*)(int,const void*,size_t,off64_t))\
+                    aSyscall[13].pCurrent)
+#else
 #define osPwrite64  ((ssize_t(*)(int,const void*,size_t,off_t))\
                     aSyscall[13].pCurrent)
+#endif
 
   { "fchmod",       (sqlite3_syscall_ptr)fchmod,     0  },
 #define osFchmod    ((int(*)(int,mode_t))aSyscall[14].pCurrent)
@@ -27909,7 +27935,7 @@
   SimulateIOError( rc=1 );
   if( rc!=0 ){
     ((unixFile*)id)->lastErrno = errno;
-    return SQLITE_IOERR_FSTAT;
+    return unixLogError(SQLITE_IOERR_FSTAT, "fstat", ((unixFile*)id)->zPath);
   }
   *pSize = buf.st_size;
 
@@ -27944,7 +27970,9 @@
     i64 nSize;                    /* Required file size */
     struct stat buf;              /* Used to hold return values of fstat() */
    
-    if( osFstat(pFile->h, &buf) ) return SQLITE_IOERR_FSTAT;
+    if( osFstat(pFile->h, &buf) ) {
+      return unixLogError(SQLITE_IOERR_FSTAT, "fstat", pFile->zPath);
+    }
 
     nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;
     if( nSize>(i64)buf.st_size ){
@@ -28510,7 +28538,7 @@
     ** with the same permissions.
     */
     if( osFstat(pDbFd->h, &sStat) && pInode->bProcessLock==0 ){
-      rc = SQLITE_IOERR_FSTAT;
+      rc = unixLogError(SQLITE_IOERR_FSTAT, "fstat", pDbFd->zPath);
       goto shm_open_err;
     }
 
@@ -29848,7 +29876,7 @@
       *pUid = sStat.st_uid;
       *pGid = sStat.st_gid;
     }else{
-      rc = SQLITE_IOERR_FSTAT;
+      rc = unixLogError(SQLITE_IOERR_FSTAT, "stat", zDb);
     }
   }else if( flags & SQLITE_OPEN_DELETEONCLOSE ){
     *pMode = 0600;
@@ -35811,12 +35839,20 @@
       ** the requested memory region.
       */
       if( !isWrite ) goto shmpage_out;
+#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE
+      if( osFallocate(pShmNode->h, sStat.st_size, nByte)!=0 ){
+        rc = unixLogError(SQLITE_FULL, "fallocate",
+                          pShmNode->zFilename);
+        goto shmpage_out;
+      }
+#else
       rc = winTruncate((sqlite3_file *)&pShmNode->hFile, nByte);
       if( rc!=SQLITE_OK ){
         rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),
                          "winShmMap2", pDbFd->zPath);
         goto shmpage_out;
       }
+#endif
     }
 
     /* Map the requested memory region into this processes address space. */
@@ -76157,7 +76193,7 @@
       }
       if( rc!=SQLITE_OK ){
         /* If an error occurred while writing to the file, close it before
-        ** returning. This way, SQLite uses the in-memory journal data to 
+        ** returning. This way, SQLite uses the in-memory journal data to
         ** roll back changes made to the internal page-cache before this
         ** function was called.  */
         sqlite3OsClose(pReal);
@@ -98953,6 +98989,14 @@
     goto pragma_out;
   }
 
+#ifdef QC_PERF
+  if( sqlite3_androidopt_handle_pragma ) {
+    if( sqlite3_androidopt_handle_pragma(db, zLeft, zRight) == 1 ) {
+      goto pragma_out;
+    }
+  }
+#endif
+
   /* Send an SQLITE_FCNTL_PRAGMA file-control to the underlying VFS
   ** connection.  If it returns SQLITE_OK, then assume that the VFS
   ** handled the pragma and generate a no-op prepared statement.
@@ -99222,6 +99266,11 @@
         /* If the "=MODE" part does not match any known journal mode,
         ** then do a query */
         eMode = PAGER_JOURNALMODE_QUERY;
+      }else if( db->isSettingOverride==1 ){
+        /* Skip journal mode changes if override in effect */
+        sqlite3VdbeAddOp4(v, OP_String, strlen(zMode), 1, 1, zMode, P4_STATIC);
+        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
+        goto pragma_out;
       }
     }
     if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){
@@ -100867,7 +100916,7 @@
   }
   if( pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT ){
     sqlite3SetString(pzErrMsg, db, "unsupported file format");
-    rc = SQLITE_ERROR;
+    rc = SQLITE_CORRUPT_BKPT; // Android Change from "rc = SQLITE_ERROR;"
     goto initone_error_out;
   }
 
@@ -122996,6 +123045,11 @@
   if( !sqlite3SafetyCheckSickOrOk(db) ){
     return SQLITE_MISUSE_BKPT;
   }
+#ifdef QC_PERF
+  if (sqlite3_androidopt_close) {
+    sqlite3_androidopt_close(db);
+  }
+#endif
   sqlite3_mutex_enter(db->mutex);
 
   /* Force xDisconnect calls on all virtual tables */
@@ -124649,6 +124703,11 @@
     }
   }
   sqlite3_mutex_enter(db->mutex);
+#ifdef QC_PERF
+  if( sqlite3_androidopt_init ) {
+    sqlite3_androidopt_init(db, zFilename);
+  }
+#endif
   db->errMask = 0xff;
   db->nDb = 2;
   db->magic = SQLITE_MAGIC_BUSY;
@@ -124770,9 +124829,9 @@
 #endif
 
 #ifdef SQLITE_ENABLE_FTS3
-  if( !db->mallocFailed && rc==SQLITE_OK ){
-    rc = sqlite3Fts3Init(db);
-  }
+    if( !db->mallocFailed && rc==SQLITE_OK ){
+      rc = sqlite3Fts3Init(db);
+    }
 #endif
 
 #ifdef SQLITE_ENABLE_ICU
@@ -124818,6 +124877,14 @@
     db = 0;
   }else if( rc!=SQLITE_OK ){
     db->magic = SQLITE_MAGIC_SICK;
+  }else {
+#ifdef QC_PERF
+    if (sqlite3_androidopt_open) {
+      int override = 0;
+      sqlite3_androidopt_open(db, zFilename, flags, &override);
+      db->isSettingOverride = override;
+    }
+#endif
   }
   *ppDb = db;
 #ifdef SQLITE_ENABLE_SQLLOG
@@ -130660,16 +130727,28 @@
   ** module with sqlite.
   */
   if( SQLITE_OK==rc 
+#ifndef ANDROID    /* fts3_tokenizer disabled for security reasons */
    && SQLITE_OK==(rc = sqlite3Fts3InitHashTable(db, pHash, "fts3_tokenizer"))
+#endif
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "snippet", -1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "offsets", 1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "matchinfo", 1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "matchinfo", 2))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "optimize", 1))
   ){
+#ifdef SQLITE_ENABLE_FTS3_BACKWARDS
+    rc = sqlite3_create_module_v2(
+        db, "fts1", &fts3Module, (void *)pHash, 0
+        );
+    if(rc) return rc;
+    rc = sqlite3_create_module_v2(
+        db, "fts2", &fts3Module, (void *)pHash, 0
+        );
+    if(rc) return rc;
+#endif
     rc = sqlite3_create_module_v2(
         db, "fts3", &fts3Module, (void *)pHash, hashDestroy
-    );
+        );
     if( rc==SQLITE_OK ){
       rc = sqlite3_create_module_v2(
           db, "fts4", &fts3Module, (void *)pHash, 0
